#!/usr/bin/env python3
"""Project git management script"""
import argparse
import asyncio
import json
import os
import sys
import shutil
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Union

class DocSourceManager:
    def __init__(self):
        self.config_path = Path(".gproj")
        self.config = self.load_config()
        self.semaphore = asyncio.Semaphore(5)

    def load_config(self) -> Dict:
        """Load .gproj configuration file"""
        if not self.config_path.exists():
            return {"docs_base_path": "~/.gproj/docs", "documentation_sources": []}
        return json.loads(self.config_path.read_text())

    def expand_path(self, path: str) -> str:
        """Expand environment variables and ~ in path"""
        return os.path.expandvars(os.path.expanduser(path))

    def transform_doc_path(self, source: Dict) -> str:
        """Transform doc source path to match workspace config"""
        base_path = self.expand_path(self.config["docs_base_path"])
        name = source["name"].replace("^docs/+", "", 1)
        return str(Path(base_path) / name)

    async def clone_doc_repo(self, source: Dict) -> bool:
        """Clone a documentation repository"""
        try:
            repo_dir = Path(self.transform_doc_path(source))
            if repo_dir.exists():
                print(f"Documentation repo {source['name']} exists, checking out {source.get('tag', 'main')}...")
                process = await asyncio.create_subprocess_exec(
                    "git", "-C", str(repo_dir), "fetch", "--all",
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
                process = await asyncio.create_subprocess_exec(
                    "git", "-C", str(repo_dir), "checkout", source.get("tag", "main"),
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
            else:
                print(f"Cloning documentation repo {source['name']}...")
                repo_dir.parent.mkdir(parents=True, exist_ok=True)
                process = await asyncio.create_subprocess_exec(
                    "git", "clone", source["repo"], str(repo_dir),
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
                if source.get("tag"):
                    process = await asyncio.create_subprocess_exec(
                        "git", "-C", str(repo_dir), "checkout", source["tag"],
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    await process.communicate()
            return True
        except Exception as e:
            print(f"❌ Error processing {source['name']}: {str(e)}")
            return False

    async def process_doc_sources(self) -> None:
        """Process all documentation sources"""
        if not self.config.get("documentation_sources"):
            return
        print("\nProcessing documentation sources...")
        base_path = Path(self.expand_path(self.config["docs_base_path"]))
        base_path.mkdir(parents=True, exist_ok=True)
        tasks = []
        for source in self.config["documentation_sources"]:
            tasks.append(self.clone_doc_repo(source))
        
        results = await asyncio.gather(*tasks)
        success = all(results)
        print("✅ Documentation sources processed" if success else "❌ Some documentation sources failed")

class ProjectInitializer:
    def __init__(self):
        self.config_path = Path(".gproj")
        if not self.config_path.exists():
            print("❌ No .gproj configuration file found")
            sys.exit(1)
        
        config = json.loads(self.config_path.read_text())
        self.project_name = config.get("project_name")
        self.repo_org = config.get("repo_org")
        self.repositories = config.get("repositories", [])
        
        if not all([self.project_name, self.repo_org, self.repositories]):
            print("❌ Missing required configuration in .gproj file")
            sys.exit(1)
            
        self.base_dir = Path("..").resolve()
        self.semaphore = asyncio.Semaphore(5)

    async def clone_repo(self, repo: Dict[str, str]) -> bool:
        """Clone a repository"""
        try:
            async with self.semaphore:
                repo_name = repo["name"]
                repo_dir = self.base_dir / repo_name
                if repo_dir.exists():
                    print(f"Repository {repo_name} exists, fetching updates...")
                    process = await asyncio.create_subprocess_exec(
                        "git", "-C", str(repo_dir), "fetch", "--all",
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    await process.communicate()
                else:
                    print(f"Cloning repository {repo_name}...")
                    repo_url = f"git@github.com:{self.repo_org}/{repo_name}.git"
                    process = await asyncio.create_subprocess_exec(
                        "git", "clone", repo_url, str(repo_dir),
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    await process.communicate()
                return True
        except Exception as e:
            print(f"❌ Error processing {repo_name}: {str(e)}")
            return False

    async def backup_repo(self, repo: Dict[str, str]) -> bool:
        """Create backup branch before nuking"""
        try:
            async with self.semaphore:
                repo_name = repo["name"]
                repo_dir = self.base_dir / repo_name
                if not repo_dir.exists():
                    return True

                print(f"Creating backup branch for {repo_name}...")
                backup_branch = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
                
                # Create and push backup branch
                process = await asyncio.create_subprocess_exec(
                    "git", "-C", str(repo_dir), "checkout", "-b", backup_branch,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
                
                process = await asyncio.create_subprocess_exec(
                    "git", "-C", str(repo_dir), "push", "origin", backup_branch,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
                
                # Remove repository
                shutil.rmtree(repo_dir)
                return True
        except Exception as e:
            print(f"❌ Error backing up {repo_name}: {str(e)}")
            return False

    async def run(self, nuke: bool = False) -> None:
        """Run initialization or nuke process"""
        doc_manager = DocSourceManager()
        await doc_manager.process_doc_sources()

        print(f"\n{'Nuking' if nuke else 'Initializing'} repositories...")
        tasks = []
        for repo in self.repositories:
            if nuke:
                tasks.append(self.backup_repo(repo))
            else:
                tasks.append(self.clone_repo(repo))

        results = await asyncio.gather(*tasks)
        success = all(results)
        action = "nuked" if nuke else "initialized"
        print(f"✅ Repositories {action}" if success else f"❌ Some repositories failed to be {action}")

async def handle_git_operations(initializer: ProjectInitializer, args: argparse.Namespace) -> None:
    """Handle git commit and push operations"""
    excluded_repos = set(args.exclude or [])
    base_dir = initializer.base_dir
    
    for repo in initializer.repositories:
        repo_name = repo["name"]
        if repo_name in excluded_repos:
            continue
            
        repo_dir = base_dir / repo_name
        if not repo_dir.exists():
            continue
            
        try:
            if args.commit:
                print(f"\nCommitting changes in {repo_name}...")
                if args.files:
                    for file in args.files:
                        process = await asyncio.create_subprocess_exec(
                            "git", "-C", str(repo_dir), "add", file,
                            stdout=asyncio.subprocess.PIPE,
                            stderr=asyncio.subprocess.PIPE
                        )
                        await process.communicate()
                else:
                    process = await asyncio.create_subprocess_exec(
                        "git", "-C", str(repo_dir), "add", ".",
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    await process.communicate()
                
                process = await asyncio.create_subprocess_exec(
                    "git", "-C", str(repo_dir), "commit", "-m", args.message,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
            
            if args.push:
                print(f"\nPushing changes in {repo_name}...")
                cmd = ["git", "-C", str(repo_dir), "push"]
                if args.branch:
                    cmd.extend(["origin", args.branch])
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                await process.communicate()
                
        except Exception as e:
            print(f"❌ Error processing {repo_name}: {str(e)}")

def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(description="Initialize or nuke project workspace")
    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument("--nuke", action="store_true", help="Remove all repositories (after creating backup branches)")
    parser.add_argument("--commit", action="store_true", help="Create a new commit")
    parser.add_argument("--message", "-m", help="Commit message")
    parser.add_argument("--push", action="store_true", help="Push changes to remote")
    parser.add_argument("--files", nargs="+", help="Specific files to stage")
    parser.add_argument("--branch", help="Branch name for push operation")
    parser.add_argument("--exclude", nargs="+", help="Exclude specific repositories")
    
    args = parser.parse_args()
    initializer = ProjectInitializer()
    if args.debug:
        print("Configuration:")
        print(json.dumps({
            "project_name": initializer.project_name,
            "repo_org": initializer.repo_org,
            "repositories": initializer.repositories
        }, indent=2))

    # Handle git operations if specified
    if args.commit or args.push:
        if args.commit and not args.message:
            print("❌ --message is required for commit operation")
            sys.exit(1)
        asyncio.run(handle_git_operations(initializer, args))
    else:
        # Run initialization or nuke
        asyncio.run(initializer.run(nuke=args.nuke))

if __name__ == "__main__":
    main()